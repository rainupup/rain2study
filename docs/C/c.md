

# C语言数据类型

| **关键字**         | **位数** | **表示范围**             | **stdint关键字** | **ST关键字** |
| ------------------ | -------- | ------------------------ | ---------------- | ------------ |
| char               | 8        | -128 ~ 127               | int8_t           | s8           |
| unsigned char      | 8        | 0 ~ 255                  | uint8_t          | u8           |
| short              | 16       | -32768 ~ 32767           | int16_t          | s16          |
| unsigned short     | 16       | 0 ~ 65535                | uint16_t         | u16          |
| int                | 32       | -2147483648 ~ 2147483647 | int32_t          | s32          |
| unsigned int       | 32       | 0 ~ 4294967295           | uint32_t         | u32          |
| long               | 32       | -2147483648 ~ 2147483647 |                  |              |
| unsigned long      | 32       | 0 ~ 4294967295           |                  |              |
| long long          | 64       | -(2^64)/2 ~ (2^64)/2-1   | int64_t          |              |
| unsigned long long | 64       | 0 ~ (2^64)-1             | uint64_t         |              |
| float              | 32       | -3.4e38 ~ 3.4e38         |                  |              |
| double             | 64       | -1.7e308 ~ 1.7e308       |                  |              |

 **stdint关键字**：为重写的关键字，推荐使用

**ST关键字**  ：为ST重写的关键字







# 指针

指针类型：指针也就是内存地址，指针变量是用来存放内存地址的变量。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：`type *var_name;`



注意：指针本身也有内存地址

````c
int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch;    /* 一个字符型的指针 */
````

所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。

不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。



**使用指针**

使用`&`号可以去地址

使用`*`号可以访问指针所指向的地址上的值

```c
int main(){
    int i = 3;

    int *p;
    p = &i;

    printf("i 的值： %d \n",i);
    printf("i 的地址： %p \n",&i);
    printf("p 指针的值： %p\n",p);
    printf("p 指针的地址： %p\n",&p);
    printf("p 指针指向的值： %d\n",*p);
}
/**
i 的值： 3
i 的地址： 000000000061FE1C
p 指针的值： 000000000061FE1C
p 的地址： 000000000061FE10
p 指针指向的值： 3
**/
```



**指针的算数运算**

指针也可以使用`+，-，++，--`这四种操作

- 指针的每一次递增，它其实会指向下一个元素的存储单元。
- 指针的每一次递减，它都会指向前一个元素的存储单元。
- 指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。

````c
#include "stdio.h"


int main(){
    int var[5] = {1,2,3,4,5};
    int *p;
    p = var;

    printf("p 指针指向的值： %d\n",*p);
    printf("p 指针的值： %p\n",p);
    printf("p 指针的地址： %p\n",&p);
    p++;
    printf("p 指针指向的值： %d\n",*p);
    printf("p 指针的值： %p\n",p);
    printf("p 指针的地址： %p\n",&p);
}
/**
p 指针指向的值： 1
p 指针的值： 000000000061FE00
p 指针的地址： 000000000061FDF8
p 指针指向的值： 2
p 指针的值： 000000000061FE04
p 指针的地址： 000000000061FDF8
**/
````





**指针的指针**

指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。

````c
#include <stdio.h>
 
int main ()
{
   int  V;
   int  *Pt1;
   int  **Pt2;
 
   V = 100;
 
   /* 获取 V 的地址 */
   Pt1 = &V;
 
   /* 使用运算符 & 获取 Pt1 的地址 */
   Pt2 = &Pt1;
 
   /* 使用 pptr 获取值 */
   printf("var = %d\n", V );
   printf("Pt1 = %p\n", Pt1 );
   printf("*Pt1 = %d\n", *Pt1 );
    printf("Pt2 = %p\n", Pt2 );
   printf("**Pt2 = %d\n", **Pt2);
 
   return 0;
}
/**
var = 100
Pt1 = 0x7ffee2d5e8d8
*Pt1 = 100
Pt2 = 0x7ffee2d5e8d0
**Pt2 = 100
**/
````



**传递指针与返回指针**

````c
int* add10(int* arr){   //+10函数
    static int arrAdd10[5];   //必须为static
    for(int i = 0;i < 5;i++){
        arrAdd10[i] = arr[i] + 10;
    }

    return arrAdd10;   //将数组作为指针出出
}
int main(){
    int arr[5] = {1,2,3,4,5};
    int* arr10;
    arr10 = add10(arr);
    for(int i = 0;i < 5;i++){
        //printf("arr10[%d] = %d \n",i,*(arr10+i));
        printf("arr10[%d] = %d \n",i,arr10[i]);
    }
}
/**
arr10[0] = 11
arr10[1] = 12
arr10[2] = 13
arr10[3] = 14
arr10[4] = 15
**/
````



**指针数组和数组指针**

指针的数组：是一个装载指针的数组

数组的指针：是一个指向数组的指针

然后，需要明确一个优先级顺序：$()>[]>*$，所以：

1. `(*p)[n]`：根据优先级，先看括号内，则p是一个指针，这个指针指向一个一维数组，数组长度为n，这是“数组的指针”，即数组指针；
2. `*p[n]`：根据优先级，先看[]，则p是一个数组，再结合*，这个数组的元素是指针类型，共n个元素，这是“指针的数组”，即指针数组。

指针数组：是多个指针变量，以数组的形式存储在内存中，占有多个指针的存储空间。

````c
int main()
{
	int a = 1;
	int b = 2;
	int *p[2];
	p[0] = &a;
	p[1] = &b;
 
	printf("%p\n", p[0]); //a的地址
	printf("%p\n", &a); //a的地址
	printf("%p\n", p[1]); //b的地址
	printf("%p\n", &b); //b的地址
	printf("%d\n", *p[0]); //p[0]表示a的地址，则*p[0]表示a的值
	printf("%d\n", *p[1]); //p[1]表示b的地址，则*p[1]表示b的值
 
 
	//将二维数组赋给指针数组
	int *pp[3]; //一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]，所以要分别赋值
	int c[3][4];
	for (int i = 0; i<3; i++)
		pp[i] = c[i];
 
	int k;
	scanf_s("%d", &k);
 
    return 0;
}

````

数组指针：是一个指针变量，占有内存中一个指针的存储空间；

````c
int main()
{
	//一维数组
	int a[5] = { 1, 2, 3, 4, 5 };
	//步长为5的数组指针，即数组里有5个元素
	int (*p)[5];
	//把数组a的地址赋给p，则p为数组a的地址，则*p表示数组a本身
	p = &a;
 
	//%p输出地址, %d输出十进制
	//\n回车
	//在C中，在几乎所有使用数组的表达式中，数组名的值是个指针常量，也就是数组第一个元素的地址，它的类型取决于数组元素的类型。
	printf("%p\n", a); //输出数组名，一般用数组的首元素地址来标识一个数组，则输出数组首元素地址
	printf("%p\n", p); //根据上面，p为数组a的地址，输出数组a的地址
	printf("%p\n", *p); //*p表示数组a本身，一般用数组的首元素地址来标识一个数组
	printf("%p\n", &a[0]); //a[0]的地址
	printf("%p\n", &a[1]); //a[1]的地址
	printf("%p\n", p[0]); //数组首元素的地址
	printf("%d\n", **p); //*p为数组a本身，即为数组a首元素地址，则*(*p)为值，当*p为数组首元素地址时，**p表示首元素的值1
	printf("%d\n", *p[0]); //根据优先级，p[0] 表示首元素地址，则*p[0]表示首元素本身，即首元素的值1
	printf("%d\n", *p[1]); //为一个绝对值很大的负数，不表示a[1]...表示什么我还不知道
 
	
	//将二维数组赋给指针
	int b[3][4];
	int(*pp)[4]; //定义一个数组指针，指向含4个元素的一维数组
	pp = b; //将该二维数组的首地址赋给pp，也就是b[0]或&b[0]，二维数组中pp=b和pp=&b[0]是等价的
	pp++; //pp=pp+1，该语句执行过后pp的指向从行b[0][]变为了行b[1][]，pp=&b[1]
 
	int k;
	scanf_s("%d", &k);
 
    return 0;
}
````



````c
int arr[5]={1，2，3，4，5};
int (*p1)[5] = &arr;
/*下面是错误的*/
int (*p2)[5] = arr;
````

不难看出，在上面的示例代码中，&arr 是指整个数组的首地址，而 arr 是指数组首元素的首地址，虽然所表示的意义不同，但二者之间的值却是相同的。那么问题出来了，既然值是相同的，为什么语句`int(*p1)[5]=&arr`是正确的，而语句`int(*p2)[5]=arr`却在有些编译器下运行时会提示错误信息呢（如在 Microsoft Visual Studio 2010 中提示的错误信息为`“a value of type"int*"cannot be used to initialize an entity of type"int(*)[5]"”）？`

其实原因很简单，在 C 语言中，赋值符号“=”号两边的数据类型必须是相同的，如果不同，则需要显示或隐式类型转换。在这里，p1 和 p2 都是数组指针，指向的是整个数组。p1 这个定义的“=”号两边的数据类型完全一致，而 p2 这个定义的“=”号两边的数据类型就不一致了（左边的类型是指向整个数组的指针，而右边的数据类型是指向单个字符的指针），因此会提示错误信息。









# 宏定义

关键字：`#define`

用途：用一个字符串代替一个数字，便于理解，防止出错；提取程序中经常出现的参数，便于快速修改

````c
//定义宏定义：
#define ABC 12345

//引用宏定义：
int a = ABC; //等效于int a = 12345;
````





# typedef

关键字：`typedef <数据类型> <别名>`

用途：将一个比较长的**变量类型**名换个名字，便于使用

````c
//定义typedef：
typedef unsigned char uint8_t;
    
//引用typedef：
uint8_t a; //等效于unsigned char a;

typedef int rainInt      //rainInt 即代表int类型
typedef int* rainpointer //rainprinter 即即代表int*类型
````



**typedef与define的区别**

1. typedef只能定义基本变量类型，如果定义的不是基本变量类型，则错误
2. define可以定义任何类型



# 结构体

关键字：`struct`

用途：数据打包，不同类型变量的集合

````c
int main(){
    struct {int a;char b} c;
    
    c.a = 2;
    c.b = 'b';
}
````



**与typedef结合**

````c
typedef  struct {
    int a;
    char b
} Ob,*POb;
int main(){
    Ob j;      
    j.a = 1;      //使用结构体名称.属性
    j.b = 'c';

    Ob* y;        //使用结构体指针->属性 
    y->a = 2;
    y->b = 'x';
    
    POb k;       //简化
    k->a = 3;
    k->b = 'd';

}
````

注意：结构体如果是指针类型的需要用`->`进行访问成员，否则使用`.`进行访问

**几种定义方式**

````c
struct {
        char* name;
        int age;
}yu,yuan;			/* yu，yuan相当于变量，直接使用 */
yu.name = 'yu';

struct person{
        char* name;
        int age;
};					/* person结构体类型，需要声明变量才能使用 */
struct person yu;
yu.name = 'yu';

typedef struct{
        char* name;
        int age;
}person,*person;		/* person结构体类型，需要声明变量才能使用 */
person yu;
yu.name = 'yu';
````

**几种赋值方式**

````c
struct person{
	char* name;
	int age;
};

int main(void){
	struct person yu;
	yu.name = "yu";
	yu.age = 12;
	
	struct person yuan = {
		.name = "yuan",
		.age = 12
	};

	printf("name:%s age:%d\r\n",yu.name,yu.age);
	printf("name:%s age:%d\r\n",yuan.name,yuan.age);
	return 0;
}
````







# 枚举

关键字：`enum`

用途：定义一个取值受限制的整型变量，用于限制变量取值范围；宏定义的集合

因为枚举变量类型较长，所以通常用typedef更改变量类型名

```c
typedef enum {TRUE = 1,FALSE=0} TF_t;   //简化
int main(){
    enum {TRUE = 1,FALSE=0} TF;
    TF  = TRUE;
    
    TF_t TF2;
    TF2 = FALSE;
}
```





# 引用外部文件

**.h**文件

````c
#ifndef __FileName_H
#define __FileName_H
//存放.c文件下的函数
#endif
````



在实施过程中，首先进行了硬件连接，将两个芯片通过GPIOA的Pin9、Pin10端口连接(接收与发送数据)

和GPIOB引脚连接起来，并正确配置了串口通信和按钮的引脚。在代码实现中，使用了适当的串口通信库，来配置和控制串口通信。同时，编写了相应的中断处理函数，以便在按钮按下时触发相应的操作。通过实施和测试，我们成功地实现了系统的功能。我们可以通过按下Pin10按钮来触发串口数据的发送操作，通过Pin12和Pin15按钮来加和减数字。系统将结果发送到另一个芯片，并通过外设显示出来。





````c
if(\\本站点\电磁阀Y启停 == 1){
   \\本站点\水池进水管流动 = 10; 
   \\本站点\水池水位 = \\本站点\水池水位+2;
}
if(\\本站点\水池水位 >= 10){
    \\本站点\水池水位 = 1;
    
}
if(\\本站点\水池水位 >= 85){
    \\本站点\水池水位 = 1;
    
}
````



````c



//水池==》 进水：3 ； 出水：-2
//水塔==》 进水：2；出水： -1
//***********复位************
if(\\本站点\复位==1)
{
\\本站点\水塔水位=0;
\\本站点\水池水位=0;
\\本站点\电机M旋转=0;
\\本站点\水塔水管流动=0;
\\本站点\水池进水管流动=0;
\\本站点\复位=0;
\\本站点\启动=0;
\\本站点\计时=0;
\\本站点\缓存当前秒=0;
\\本站点\进水阀报警时间=4;
\\本站点\进水阀Y启停=0;
\\本站点\进水阀Y故障=0;
\\本站点\进水阀Y故障报警=0;
\\本站点\电机M启停=0;
}

//*************水池进水*****************************************
//当水池水位低于S4时就打开水阀进水
if(\\本站点\水池水位<=10 && \\本站点\启动==1){
  \\本站点\进水阀Y启停=1; 
}
if(\\本站点\进水阀Y启停==1){
\\本站点\水池进水管流动=10;
}

//当水位到S3时就停止进水
if( \\本站点\水池水位>=90){
    \\本站点\进水阀Y启停=0;
    \\本站点\水池进水管流动=0;
}
//当有故障时就停止进水
if(\\本站点\进水阀Y故障==1 ){
    \\本站点\水池进水管流动=0;
}

//阀Y打开进水（Y为ON），定时器开始定时，
if(\\本站点\缓存当前秒 !=\\本站点\$秒 && \\本站点\进水阀Y启停==1 && \\本站点\启动==1){
    \\本站点\缓存当前秒 =\\本站点\$秒;
    \\本站点\计时=\\本站点\计时+1;
}
//***\进水阀Y停止时，不计时
if(\\本站点\进水阀Y启停==0){
    \\本站点\计时=0;
}
//4秒后，如果S4还不为OFF，那么阀Y指示灯闪烁，表示阀Y没有进水，出现故障
if(\\本站点\计时>=\\本站点\进水阀报警时间 && \\本站点\水池水位<=10){
    \\本站点\进水阀Y故障报警=1;
}else{
\\本站点\进水阀Y故障报警=0;
}
//***********水池进水：3
if(\\本站点\进水阀Y启停==1 && \\本站点\水池进水管流动 !=0 ){
    \\本站点\水池水位=\\本站点\水池水位+3;
}


//*************水塔进水*****************************************
//水塔出水：-1
\\本站点\水塔水位=\\本站点\水塔水位-1;
if(\\本站点\水塔水位<=0){
    \\本站点\水塔水位=0;
}

//当S4为OFF时，且水塔水位低于水塔低水位界时S2为ON，电机M运转，向水塔抽水
if(\\本站点\水塔水位<=10 && \\本站点\水池水位 >=10){    
    \\本站点\电机M启停=1;
}
//***水塔水位，当水塔水位高于水塔高水位界（S1为ON）时电机M停止。
if(\\本站点\水塔水位>=100) //水塔水位已达最高
{
    \\本站点\水塔水位=100;
 }
if(\\本站点\水塔水位>=100 || \\本站点\水池水位<=10)
{
    \\本站点\电机M启停=0;
}

//电机：1==》启动：抽水； 0==》停止
if(\\本站点\电机M启停==1 && \\本站点\启动==1)
{
    \\本站点\水塔水管流动=10;
    \\本站点\水塔水位=\\本站点\水塔水位+2;
    \\本站点\水池水位=\\本站点\水池水位-2;
     \\本站点\电机M旋转=\\本站点\电机M旋转+20;
    if(\\本站点\电机M旋转>=360)
    {
    \\本站点\电机M旋转=0;
    }
}
else
{
    \\本站点\水塔水管流动=0;
}


//*************停止
if(\\本站点\启动==0)
{
\\本站点\水塔水管流动=0;
\\本站点\水池进水管流动=0;
\\本站点\进水阀Y启停=0;
\\本站点\电机M启停=0;
}
````









# 知识

字节对齐：用空间换速度
