**Linux文件系统**

![image-20220716103554345](linux.assets/image-20220716103554345.png)

| 目录      | 含义                                     | 描述                                                         |
| --------- | ---------------------------------------- | ------------------------------------------------------------ |
| /bin      | Binaries(二进制文件)                     | 存放着最经常使用的命令                                       |
| /boot     |                                          | 存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件 |
| /dev      | Device(设备)                             | 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 |
| /etc      | Etcetera(等等)                           | 存放所有的系统管理所需要的配置文件和子目录                   |
| /home     |                                          | 用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的alice、bob和eve |
| /lib      | Library(库)                              | 存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库 |
| /root     |                                          | 系统管理员，也称作超级权限者的用户主目录                     |
| /sbin     | Superuser Binaries(超级用户的二进制文件) | 存放的是系统管理员使用的系统管理程序                         |
| /tmp      | temporary(临时)                          | 存放一些临时文件的                                           |
| /usr      | unix shared resources(共享资源)          | 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录 |
| /usr/bin  |                                          | 系统用户使用的应用程序与指令                                 |
| /usr/sbin |                                          | 超级用户使用的比较高级的管理程序和系统守护程序               |
| /usr/src  |                                          | 内核源代码默认的放置目录                                     |
| /var      | variable(变量)                           | 系统和程序运行产生的日志文件和缓存文件放在这里               |



**主要配置文件**

* /etc/profile
* /etc/profile.d/*.sh       #profile.d目录下所有的.sh文件

* ~/.bash_profile           # ~代表用户目录
* ~/.bashrc
* /etc/bashrc

/etc/目录下的配置文件对所有用户生效，~目录下仅对当前用户生效





# 基本命令

## 目录

<font color=#0000FF>**显示目录**</font>：`ls`  list

语法：`ls [-ald] [文件或目录]`

* `-a` 显示所有文件，包括隐藏文化 以点开头的是隐藏文件

* `-l` 详细信息显示（long 以长格式显示）

* `-lh` 与 `-l`相似（显示的信息更人性化）（h是human）

* `-d` 查看目录属性

* `-i` 查看i节点



<font color=#0000FF>**创建目录**：</font>`mkdir`   make directory （创建 目录）

语法： 

* `mkdir -p [目录名]` 递归创建

* `mkdir -m [权限] [目录名]` 配置目录的权限

````shell
$ mkdir -p/tmp/one/two    # 创建文件夹one再在one文件夹下创建two
$ mkdir /tmp/one /tmp/two # 在tmp文件夹下创建两个文件夹one 和two
````



<font color=#0000FF>**切换目录**</font>：`cd`   change directory (更改 目录)

语法： `cd [目录]`

````shell
$cd /tmp/one/two # 切换至two文件夹
$cd ..           # 返回上一级目录 .是本目录 ..是上一级目录
````



<font color=#0000FF>**显示当前路径：**</font>`pwd`       print working directory （打印 工作 目录）

语法：`pwd [选项]`

* -P: 显示确实的路径，而非使用连接

 

<font color=#0000FF>**复制文件或目录：**</font>`cp`         copy （拷贝）

语法：`cp [选项] [原文件或目录] [目标目录]`

* `-r` 复制目录

* `-p` 保留文件属性

* `-u` 源文件比目标目录新才复制

* `-l` 建立硬式连接

* `-s` 建立软链接

* `-d` 如果是链接文件，则复制链接文件



<font color=#0000FF>**移动文件：**</font>`mv`           move （移动）

语法：`mv [选项] [原文件或目录] [目标目录]`

* `-f` 强制

* `-I` 询问是否掩盖

* `-u` 若目标文件已经存在，且源文件比较新，目标文件才会更新



<font color=#0000FF>**删除文件或目录：**</font>`rm`      remove （去掉）

语法: `rm [选项] [文件或目录]`

* `-r` 删除目录
* `-f` 强制执行

使用 rm 命令要小心，因为文件删除后不能恢复



<font color=#0000FF>**删除空目录：**</font>`rmdir`          remove empty directory （去掉 空的 目录）

语法：`rmdir [目录名]`



<font color=#0000FF>**文件查找：**</font>`find`

语法：`find 搜索范围 [搜索方式] 匹配条件`

* `-name` 以文件名搜索
  * `* `匹配任意字符串
  * `？`匹配任意字符
* `-iname` 不区分大小写
* `-size` 以文件大小搜索 
* +n 大于  -n 小于 n 等于
* `-user` 以所有者搜索
* `-group` 以所属组搜索
* `-cmin` 以文件属性被修改时间搜索
* `-mmin` 以文件内容被修改时间搜索
* `-amin` 以访问时间搜索

* `-a` 两个条件同时满足

* `-o` 两个条件满足任意一个

* `-type` 根据文件类型查找
  * f 文件 d 目录 l 软连接

````shell
find /etc -name ^a                              # 查找/etc下以a开头的文件
find /tmp -size +204800                         # 在tmp目录下查找大于100M的文件
find /etc -cmin -5                              # 在/etc目录下搜索 5 分钟内被修改过的文件
find /etc -cmin +5                              # 在/etc目录下搜索 5 分钟外被修改过的文件
find /etc -size +163840 -a -size -204800         # 在/etc 下查找大于80M小于100M的文件
````



<font color=#0000FF>**排序：**</font>`sort`

语法：`sort [选项] [文件]`

* `-b`	忽略每行前面开始出的空格字符
* `-c`	检查文件是否已经按照顺序排序
* `-d`	排序时，处理英文字母、数字及空格字符外，忽略其他的字符
* `-f`	排序时，将小写字母视为大写字母
* `-n`	依照数值的大小排序
* `-o`	<输出文件> 将排序后的结果存入制定的文件
* `-r`	以相反的顺序来排序
* `-t`	<分隔字符> 指定排序时所用的栏位分隔字符




## 文件

<font color=#0000FF>**创建文件：**</font>`touch`

语法：`touch [文件名]`



<font color=#0000FF>**显示文件内容：**</font>`cat`         concatenate

语法：`cat [文件名]`

* `-n` 显示行号

* `-b` 显示行号(非空白行)

* `-A` 显示特殊字符

````shell
$ cat -n /etc/issue
````



<font color=#0000FF>**反向显示文件内容：**</font>`tac` 

语法：`tac[文件名]`

 

<font color=#0000FF>**分页显示文件内容：**</font>`more`

语法： `more[文件名]`

操作：

* (空格)或f翻页

* (Enter)换行

* Q 或 q退出



<font color=#0000FF>**分页显示文件内容(可向上翻页)：**</font>`less`

语法： `less[文件名]`

操作：

* (空格) 或 f 向下翻页

* PgUp 向上翻页

* (Enter)    换行

* Q 或 q    退出

* /  搜索 （N 寻找下一个搜索的单词）



<font color=#0000FF>**显示文件前N行：**</font>`head`

语法: `head [文件名]` (默认前10行)

* `-n` 指定行数

````shell
$ head -n 20 /etc/services
````

 

<font color=#0000FF>**显示文件后N行：**</font>`tail`

语法: `tail [文件名]` (默认后10行)

* `-n` 指定行数

* `-f` 动态显示文件末尾内容

````shell
$ tail -n 20 /etc/services
````



 

<font color=#0000FF>**生成链接文件：**</font>`ln`

语法：

* `ln [原文件] [目标文件]`    生成硬链接

* `ln -s [原文件] [目标文件]` 生成软连接

软链: 类似快捷方式

1. lrwxrwxrwx  l代表软链接
2. 文件大小 - 只是符号连接
3. /tmp/issue.soft -> /etc/issue 箭头指向原文件

硬链:

1. 相当于拷贝 cp -p +同步更新
2. 通过 i 节点识别
3. 不能跨分区
4. 不能针对目录使用



<font color=#0000FF>**搜索文本文件内容：**</font>`grep`

语法：`grep [选项] 搜索的文本 文件名`  支持正则搜索

* `-n` 显示匹配行及行号

* `-v` 显示不包含匹配文本的所有行（相当于求反）

* `-i` 忽略大小写



<font color=#0000FF>**文字替换与删除：**</font>`tr`

语法：`tr [选项] [第一字符集] [第二字符集]` 

````shell
last | tr '[a-z]' '[A-Z]' 
#将last输出的讯息所有的小写转换为大写

cat /etc/passwd | tr -d ':'
#删除passwd配置文件的冒号
````



<font color=#0000FF>**文件合并：**</font>`paste`

语法：`paste [选项] 文件1 文件2`

* `-d` 后面指定分隔符，默认tab



<font color=#0000FF>**文件对比：**</font>`diff`

语法：`diff [选项] 文件1 文件2`

* `-b` 忽略一行当中，仅有多个空白的差异(例如“about me”与“about    me”视为相同)
* `-B` 忽略空白行的差异
* `-i` 忽略大小写



## 字符

<font color=#0000FF>**截取：**</font>`cut`

语法：`cut [选项] 文件名`

* `-f 列号`    提取第几列
* `-d 分隔符`  按照指定分隔符分隔列

````shell
[root@localhost ~]# cut -f 2 student.txt
#提取第2列
[root@localhost ~]# cut -f 2,3 student.txt
#提取第2、3列
[root@localhost ~]# cut -d ":" -f 1,3 /etc/passwd
#提取以：分隔的第1、3列
````



<font color=#0000FF>**输出：**</font>`printf` 

语法：`printf '输出类型输出格式’ 输出内容`

* %ns:     输出字符串  n是数字指代输出几个字符
* %ni:     输出整数    n是数字指代输出几个数字
* %m. nf:  输出浮点数  m和n是数字，指代输出的整数位数和小数位数



<font color=#0000FF>**AWK：**</font>

* `awk [选项] '条件1 {动作1} 条件2 {动作2}…' 文件名`

* `awk [选项] 'BEGIN{ commands } 条件1 {commands} 条件2 {commands} ... END{ commands }'`

  * `BEGIN{ commands }`开始块就是在程序启动的时候执行的代码部分，并且它在整个过程中只执行一次。一般情况下，我们可以在开始块中初始化一些变量。开始块部分是可选的，你的程序可以没有开始块部分。
  * `条件1 {commands} 条件2 {commands}` 部分匹配该行内容成功后，才会执行commands 的内容。
  * `END{ commands }`结束块是在程序结束时执行的代码。结束块部分也是可选的

  选项：

  * `-F` 改变字段分隔

**awk常用系统变量**

| 变量 | 描述（列举常用的，还有很多其他的没怎么常用）                 |
| ---- | ------------------------------------------------------------ |
| $n   | **$1当前记录的第1个字段的内容**。**和sed中的$1不同,sed表示第一个参数** |
| $0   | 整行数据的内容                                               |
| FS   | 字段分隔符 (默认是空格)                                      |
| NR   | 目前awk所处理的是第几行内容                                  |
| NF   | 一行中字段数量，最后一个字段内容可以用$NF取出                |
| OFS  | 输出字段的分隔符（默认是空格）                               |
| RS   | 行分隔符（默认以\n作为一行的结尾），单行分割成多行用到       |
| FNR  | 各文件分别计数的行号，多文件的时候会和NR不同，它会重新计数   |
| ARGC | 命令行参数的数目                                             |
| ARGV | 包含命令行参数的数组，第一个参数是命令awk                    |

````shell
awk -F, '{print $1,$2}' 1.txt   # 使用","分割。-F相当于内置变量FS, 指定分割字符

cat /etc/passwd | grep "/bin/bash"| awk 'BEGIN {FS=":"} {printf$1 "\t" $3 "\n"}'   # 以:分割

awk 'BEGIN {FS=":"} {printf$1 "\t lines:" NR "\t columns:" NF "\n"}' /etc/passwd
    # 输出：
    # root	 lines:1	 columns:7
    # bin	 lines:2	 columns:7
    # dae	 lines:3	 columns:7
````





## 权限

| 代表字符 | 描述   |
| -------- | ------ |
| u        | 所有者 |
| g        | 所属组 |
| o        | 其他人 |
| a        | 全部   |

| 代表字符 | 权限 | 对文件           | 对目录                     |
| -------- | ---- | ---------------- | -------------------------- |
| r 4      | 读   | 可以查看文件内容 | 可以列出目录中的内容       |
| w 2      | 写   | 可以修改文件内容 | 可以在目录中创建、删除文件 |
| x 1      | 执行 | 可以执行文件     | 可以进入目录               |



<font color=#0000FF>**权限权限：**</font>`chmod`    change the permissions mode of a file

语法：

* `chmod {u,g, o,a} {+ - =} {r w x} 文件或目录`

* `chmod 数字 文件或目录` 
  * `-R` 递归修改

![image-20220716120534040](linux.assets/image-20220716120534040.png)

````shell
# 给文件的所有者添加执行权限
chmod u+x 文件名

# 给文件的其他人删除所有权限
chmod o-rwx 文件名

# 给文件的所属组设置读写权限
chmod g=wx 文件名

# 设置文件的权限为(所有者可读可写可执行，所属组可读可写，其他人可读)
chmod 764 文件名
````

 

<font color=#0000FF>**所有者设置：**</font>`chown`       change file ownership

语法： 

* `chown [选项] 目标用户 文件或目录`

* `chown [选项] 目标用户:目标组 文件或目录`        同时修改文件的用户和所属组
  * `-R` 递归 

````shell
$chown shanghai ceshi      # 改变ceshi文件的所有者为shanghai
````

 

<font color=#0000FF>**所属组设置：**</font>`chgrp`            change file group ownership

语法： `chown 目标用户组 文件或目录`

````shell
$chgrp shanghai ceshi     # 改变ceshi文件的所属组为shanghai
````

 

<font color=#0000FF>**显示、设置文件的缺省权限：**</font>`umask`      the user file creation mask

语法: `umask 设置文件缺省文件`（异或）

* `-S` 以rwx形式显示新建文件缺省权限               

​                   

## 用户

**简介**

* 越是对服务器安全性要求高的服务器，越需要建立合理的用户权限等级制度和服务器操作规范

* 在Linux中主要是通过用户配置文件来查看和修改用户信息

 

**用户信息文件** `/etc/passwd`

````txt
account : password : UID : GID : GECOS : directory : shell （帐号:密码:用户ID:组ID:一般的信息:目录:shell）
第1字段：  用户名
第2字段：  密码标志
第3字段：  UID（用户ID）
            0              超级用户（root）
            1 ~ 499        系统用户（伪用户）     （CentOS 1 ~ 999） （不能登录，不能删除）
            500 ~ 65535    普通用户             （CentOS 1000 ~ 65535）
第4字段：  GID（用户初始组ID）
            初始组和附加组
            	1) 初始组：指用户一登录就拥有这个用户组的相关权限，每个用户的初始组只能有一个，一般就是和这
            		      个用户的用户名相同的组名作为这个用户的初始组
                2) 附加组：指用户可以加入多个其它的用户组，并拥有这些组的权限，附加组可以有多个。
第5字段：  用户说明
第6字段：  家目录
            1) 普通用户：/home/用户名/
            2) 超级用户：/root/
第7字段：登录后的Shell
        Shell是什么？
            1) Shell就是Linux的命令解释器
            2) 在/etc/passwd当中，除了标准Shell是/bin/bash之外，还可以写成如/sbin/nologin
````



**影子文件 **`/etc/shadow`

````txt
第1字段：用户名
第2字段：加密密码
	1. 加密算法为SHA512散列加密算法
    2. 如果加密位是 ！！ 或 * 代表没有密码，不能登录 （把此字段的加密密码前添加！！号会禁用次用户）
第3字段：密码最后一次修改日期
    使用1970年1月1日作为标准时间，每过一天时间戳加1
第4字段：下一次密码修改的间隔时间（与字段3相比）
第5字段：密码有效期（与字段3相比）
第6字段：密码修改到期前的警告天数（和5字段相比）
第7字段：密码过期后的宽限天数（和5字段相比）
        0：代表密码过期后立即失效
       -1：代表密码永不失效
第8字段：账号失效时间（时间戳表示）忽略5、6、7字段
第9字段：保留（没用）
````

````txt
shanghai:加密字段:18470:10:90:7:5::

用户shanghai
密码最后修改日期1970-1-1后的第18470天
下次能修改密码的日期1970-1-1后的第18470 + 10 天
密码有效期90天，在第90 - 7 = 83天提醒，宽限5天
````



**用户的邮箱**`/var/spool/mail/用户名/`

**用户模板目录**`/etc/skel/`

````shell
cd /etc/skel/
vim hello.txt
# 下次创建用户的时候会自动在用户家目录下创建hello.txt文件
````



<font color=#0000FF>**添加用户：**</font>`useradd`

语法：`useradd 用户名`

* `-u` 指定用户的UID号
* `-d` 指定用户的家目录
* `-c` 指定用户的说明
* `-g` 指定用户的初始组
* `-G` 指定用户的附加组
* `-s` 指定用户的登录shell。默认是/bin/bash

````shell
useradd rain # 添加用户rain

#添加用户rain UID:1337 附加组：root、shanghai 家目录：/home/lampl 说明：user rain shell路径：/bin/bash
useradd -u 1337 -G root，shanghai -d /home/lampl -c "user rain" -s /bin/bash rain
````



<font color=#0000FF>**设置用户密码：**</font>`passwd`

语法：命令行输入`passwd 用户名`后弹出修改密码的命令行

* 普通用户：`passwd 用户名`
* Root用户：`passwd [选项] 用户名`
  * `-S` 查询用户密码的密码状态
  * `-l` 暂时锁定用户
  * `-u` 解锁用户
  * `--stdin` 可用通过管道符输出的数据作为用户的密码

 

<font color=#0000FF>**修改用户信息：**</font>`usermod`

语法：`usermod [选项] 用户名`

* `-u` 修改用户的UID号

* `-c` 修改用户的说明信息

* `-G` 修改用户的附加组

* `-L` 临时锁定用户 

* `-U` 解锁用户锁定   



<font color=#0000FF>**修改用户密码状态：**</font>`chage`                             （直接使用vim修改shadow文件更好）

语法：`chage [选项] 用户名`

* `-l`  列出用户的详细密码状态
* `-d`  日期  修改密码最后一次改过时间    （shadow 3字段）
* `-m`  天数  两次密码修改间隔           （shadow 4字段）
* `-M`  天数  密码有效期                （shadow 5字段）
* `-W`  天数  密码过期前警告天数          （shadow 6字段）
* `-I`  天数  密码过期后的宽限天数        （shadow 7字段）
* `-E`  日期  账号失效时间               （shadow 8字段）

````shell
chage -d 0 用户名
#这个命令其实是把密码修改日期归0了
#这样用户第一次登陆就需要修改密码
````



<font color=#0000FF>**删除用户：**</font>`userdel`

语法：`userdel -r 用户名`



<font color=#0000FF>**查看用户ID：**</font>`id 用户名`

<font color=#0000FF>**切换用户身份：**</font>`su`

语法：`su [选项] 用户名`

* `-`  选项只使用 `-` 代表连带用户的环境变量一起切换
* `-c `仅执行一次命令，而不切换用户身份

````shell
su - root -c “useradd user1”
# 不切换成root，但执行useradd命令添加user1用户
````

<font color=#0000FF>**查看登录用户信息：**</font>`who`

内容：

* tty 代表本地终端

* pts 代表远程终端

<font color=#0000FF>**查看登录用户详细信息：**</font>`w`



## 用户组

**组信息文件** `/etc/group`

````txt
第1字段： 组名
第2字段： 组密码标志（如果为空，则不需要密码）
第3字段： GID（组的数字标识）
第4字段： 组中附加用户（组内成员用户名，以逗号分隔）
````



**组密码文件** `/etc/gshadow`

````txt
第1字段：组名
第2字段：组密码
第3字段：组管理员用户名（管理员可以更改组密码和组成员）
第4字段：组中附加用户
````

 

<font color=#0000FF>**添加用户组：**</font>`groupadd` 

语法：`groupadd [选项] 组名`

* `-g` 指定组ID



<font color=#0000FF>**修改用户组：**</font>`groupmod`

语法：`groupmod [选项] 组名`

* `-g 组ID 组名`        修改组ID

* `-n 新组名 旧组名`     修改组名



<font color=#0000FF>**删除用户组：**</font>`groupdel 组名`

<font color=#0000FF>**把用户添加入组或从组删除：**</font>`gpasswd`

语法：`gpasswd [选项] 用户名 组名`

* `-a 用户名 组名`         把用户加入组

* `-A 用户名 组名`         设置用户组管理员

* `-d 用户名 组名`         把用户从组中删除



<font color=#0000FF>**查看用户的有效组：**</font>`groups`

<font color=#0000FF>**切换用户组：**</font>`newgrp`

````shell
newgrp xr   #切换到xr组
````





## 压缩/解压

<font color=#0000FF>**打包目录/解压**</font>：`tar`

压缩后文件格式：`.tar` `.gz`

语法： 

* **压缩文件：**`tar [-zcf] 压缩后文件名 目标文件`
  
  * `-c` 打包
  * `-v` 显示详细信息
  * `-f` 指定文件名  （必须）
  * `-t` 查询打包文件的内容
  * `-p` 保留原权限和属性
  * `-z` 打包同时压缩（tar.gz）或 `-j` 打包同时压缩（tar.bz2）或 `-J` 打包同时压缩（tar.xz）
* `--exclude` 排除某个文件 例：`tar -jvfc test.tar.bz2 --exclude=/xuexi/test1 /xuexi` (打包压缩xuexi目录，去除test1文件)
  

  
* **解压：**`tar [-xfz] 解压文件名` 
  
  * `-x` 解包
  * `-v` 显示详细信息
  * `-f` 指定解压文件  （必须）
  * `-C` 指定解压后的文件存放的位置 例：`tar -xjvf test.tar.bz2 -C /tmp`
  * `-z` 解压缩（.tar.gz） 或 `-j` 解压缩(.tar.bz2) 或 `-J` 解压缩（tar.xz）

````shell
tar -zcf cs.tar.gz ceshi    # ceshi打包并压缩 cs.tar.gz
tar -zxf cs.tar.gz          # 解压缩cs.tar.gz
````





## 网络

**IP配置地址** `/etc/stsconfig/network-scripts/ifcfg-eth0`

`service network restart` 重启网络服务



**主机名**

查看主机名文件：

```
vi /etc/sysconfig/network
```

内容如下：

```
NETWORKING=yes
HOSTNAME=rain
```

* `/etc/sysconfig/network`该文件中`NETWORKING=no`时主机将无法连接网络。

* 修改`/etc/sysconfig/network`文件中的主机名后需要重启计算机才能生效。使用`hostnamectl set-hostname 主机名`命令可以临时更改主机名后，重启计算机后将失效。通过`hostname`命令可以查看当前主机名。
  



<font color=#0000FF>**测试网络连通性：**</font>`ping`

语法：`ping [选项] ip地址`

* `-c` 指定发送次数

 

<font color=#0000FF>**查看和设置网卡信息：**</font>`ifconfig `        interface configure



<font color=#0000FF>**显示数据包到主机间的路径：**</font>`traceroute`

语法:`traceroute 网站/IP`

 

<font color=#0000FF>**显示网络相关信息：**</font>`netstat`

语法：`netstat [选项]`

* `-t`   TCP协议
* `-u`   UDP协议
* `-l`   监听
* `-r`   路由
* `-n`   显示IP地址和端口

````shell
netstat -tlun # 查看本机监听的端口
netstat -an   # 查看本机所有的网络连接
netstat -rn   # 查看本机路由表
````



<font color=#0000FF>**防火墙：**</font>服务名`firewalld`

| 命令                       | 描述                                               |
| -------------------------- | -------------------------------------------------- |
| systemctl start firewalld  | 开启防火墙                                         |
| systemctl stop firewalld   | 关闭防火墙                                         |
| systemctl status firewalld | 查看firewalld状态，显示active（running）即已开启了 |

**查看开放的端口：**`firewall-cmd --list-all`

**设置开方端口号：**

1. `firewall-cmd --add-service=http –permsystemctanent`

2. `firewall-cmd --add-port=8090/tcp --permanent`  

3. 设置之后需要重启防火墙`firewall-cmd --reload`



<font color=#0000FF>**端口的占用情况：**</font>`lsof`     list open files 

本命令不仅可以查看端口，是一个查看进程打开的文件的工具

语法：

* `lsof -i`     查看后台运行情况
* `lsof -i:端口` 查看端口是否被占用 



<font color=#0000FF>**配置网络：**</font>`setup`

<font color=#0000FF>**挂载命令：**</font>`mount`

语法：`mount [-t 文件系统] [设备文件名] [挂载点]`

````shell
mount -t iso9660 /dev/sr0 /mnt/cdrom
````



<font color=#0000FF>**给在线用户发信息：**</font>`write`

语法：`writh [用户名]`

* Ctrl + D结束

````shell
write shanghai
Hello Linux

# 给shanghai发送hello linux信息
````



<font color=#0000FF>**不接收信息：**</font>`mesg`

语法：`mesg [选项]`

* `n` 不接收信息

* `y` 恢复接收信息

 

<font color=#0000FF>**发广播信息给所有人：**</font>`wall`          write all

语法：`wall [发送的信息]`

 

<font color=#0000FF>**列出目前与过去登录系统的用户信息：**</font>`last`

<font color=#0000FF>**检查某特定用户上次登录的时间信息：**</font>`lastlog`

语法：`lastlog -u [uid]` 检查特定用户



## 软件

> YUM

yum基于rpm实现的，提供了除了rpm的安装软件、卸载软件等功能以外还有，自动查找、下载软件并自动处理软件的彼此之间的依赖关系，下载并安装依赖包。



**查询：**

* `yum list`  查询所有可用软件包列表
* `yum search （包名）`  搜索服务器上所有和关键字相关的包



**安装：**

* `yum -y install 包名`
  * `-y`    自动回到yes

**升级：**

* `yum -y update 包名`
* 注意：一定要加包名，否则升级所有内容（包括Linux内核）

**卸载：**

* `yum -y remove 包名`

* 注意：会自动卸载所有依赖的包，可能造成其他包 和 Linux系统的崩溃；

* 提醒：尽量不使用yum卸载



> RPM

**RPM包命名规则**

````txt
hrrpd-2.2.15-15.e16.centos.1.i686.rmp
httpd                 软件包名
2.2.15                软件版本
15                    软件发布的次数
e16.centos            适合的linux平台
i686                  适合的硬件平台
rpm                   RPM包扩展名
````



**安装：**

* `rpm -ivh 包全名`         
  * `-i` （install）     安装
  * `-v` （verbose）     显示详细信息
  * `-h` （hash）        显示进度` 
  * `--nodeps`           不检测依赖性

**升级：**

* `rpm -Uvh 包全名`
  * `-U` （upgrade）     升级

**卸载：**

* `rpm -e 包名`



## 服务启动

| daemon命令             | systemctl命令                 | 说明                               |
| :--------------------- | :---------------------------- | :--------------------------------- |
| service [服务] start   | systemctl start [unit type]   | 启动服务                           |
| service [服务] stop    | systemctl stop [unit type]    | 停止服务                           |
| service [服务] restart | systemctl restart [unit type] | 重启服务                           |
|                        | systemctl status [unit type]  | 查看服务运行情况                   |
|                        | systemctl reload [unit type]  | 重新加载服务，加载更新后的配置文件 |



## 运行级别

| 运行级别 | 含义                                            |
| -------- | ----------------------------------------------- |
| 0        | 关                                              |
| 1        | 单用户模式，windows的安全模式，主要用于系统修复 |
| 2        | 不完全的命令行模式，不含NFS服务                 |
| 3        | 完全的命令行模式                                |
| 4        | 系统保留                                        |
| 5        | 图形模式                                        |
| 6        | 重启动                                          |

<font color=#0000FF>**查看运行级别命令：**</font>`runlevel`

<font color=#0000FF>**改变运行级别命令：**</font>`init 运行级别`



## 关机/重启

<font color=#0000FF>**关机/重启：**</font>`Shutdown`

语法：`shutdown [选项] 时间 [信息]`

* `-c` 取消前一个关机命令
* `-h` 关机
* `-r` 重启
* `-k` 发出警告信息

````shell
shutdown -h now     # 现在关机
shutdown -r 20：30  # 八点半重启
````



**其它关机命令:**`halt`、`poweroff`、`Init 0`

**其它重启命令：**`reboot`、`init 6`



**查询系统运行级别：**`Runlevel`

**退出登录命令：**`logout`

**将数据同步写入硬盘**(将内存中的数据写入硬盘)：`sync`



## 定时任务

语法：`crontab [选项]`

* `-e`          执行文字编辑器来设定时程表
* `-l`          查询crontab任务
* `-r`          删除当前用户所有的crontab任务

````shell
[root@localhost ~ ]# crontab -e
#进入crontab编辑界面。会打开vim 编辑你的工作
````

**设置任务**

| 项目     | 含义         | 范围                      |
| -------- | ------------ | ------------------------- |
| 第一个 * | 分钟         | 0 - 59                    |
| 第二个 * | 小时         | 0 - 23                    |
| 第三个 * | 天           | 1 - 31                    |
| 第四个 * | 月           | 1 - 12                    |
| 第五个 * | 星期         | 0 - 7（0、7都代表星期日） |
| program  | 要执行的程序 |                           |

| 特殊符号 | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| *        | 任意时间                                                     |
| ，       | 不连续的时间，例：0 8,12,16 * * *命令 代表每天的8、12、16都会执行 |
| -        | 连续的时间范围，例：0 5  * * 1-6 命令 代表每周一五点执行     |
| */n      | 每隔多久执行一次，例：*/10  * * * * 命令 代表每10分钟执行一次 |

````txt
45 22 * * *    在22点45执行
0 17 * * 1     每周一15点执行
0 5 1,15 * *   每月1号和15号5点执行
40 4 * * 1-5   每周一到周五4点40执行
*/10 4 * * *   每天4点，每隔10分钟执行一次
0 0 1,15 * 1   每月1号15号 和星期一都会执行
5 5 * * 2 /sbin/shutdown -r now 每星期二5点5分执行重启任务
````

 

## 备份/恢复

<font color=#0000FF>**备份：**</font>`dump`

语法： `dump [选项] 备份之后的文件名 原文件或目录`

* `-level`          就是我们说的0-9十个备份级别
* `-f文件名`         指定备份之后的文件名
* `-u`              备份成功之后，把备份时间记录在/etc/dumpdates文件
* `-v`              显示备份过程中更多的输出信息
* `-j`              调用bzlib库压缩备份文件(.bz2格式)
* `-W`              显示允许被dump的分区的备份等级及备份时间



<font color=#0000FF>**恢复：**</font>`restore`

语法：`restore [模式选项] [选项]`

* 模式选项: restore命令常用的模式有以下四种，这四个模式不能混用。
  * `-C`         比较备份数据和实际数据的变化
  * `-i`         进入交互模式，手工选择需要恢复的文件。
  * `-t`         查看模式，用于查看备份文件中拥有哪些数据。
  * `-r`         还原模式，用于数据还原。

* 选项:
  * `-f`         指定备份文件的文件名



## 其他

> echo 文字内容

echo 会在终端中显示参数指定的文字，通常会和 重定向 联合使用

语法：`echo [选项] [输出内容]`

| 控制字符 | 作用                                                         |
| -------- | ------------------------------------------------------------ |
| \        | 输出\本身                                                    |
| \a       | 输出警告音                                                   |
| \b       | 退格键，向左删除                                             |
| \c       | 取消输出行末的换行符。和“-n”选项一致                         |
| \e       | ESCAPE键                                                     |
| \f       | 换页符                                                       |
| \n       | 换行符                                                       |
| \r       | 回车键                                                       |
| \t       | 制表符，也就是Tab键                                          |
| \v       | 垂直制表符                                                   |
| \0nnn    | 按照八进制ASCII码表输出字符。其中0位数字0，nnn是三位八进制数 |
| \xhh     | 按照十六进制ASCll码表输出字符。其中hh是两位十六进制数        |

>重定向 > 和 >>

Linux 允许将命令执行结果 重定向到一个 文件
将本应显示在终端上的内容 输出／追加 到指定文件中

* `>` 表示输出，会覆盖文件原有的内容

* `>>`表示追加，会将内容追加到已有文件的末尾

![image-20220717154406805](linux.assets/image-20220717154406805.png)

![image-20220717154414038](linux.assets/image-20220717154414038.png)





> 管道 |

Linux 允许将 一个命令的输出 可以通过管道做为 另一个命令的输入

常用的管道命令有：
`grep` ：在命令执行结果的基础上查询指定的文本



> 命令别名

* `alias 别名='原命令'`   设定命令别名(临时生效)

* `alias`  查询命令别名

* `vi /root/.bashrc 修改/home/用户名/.bashrc文件`  别名永久生效 

* `unalias 别名`  删除别名

* 命令执行时顺序

* 1. 第一顺位执行用绝对路径或相对路径执行的命令
  2. 第二顺位执行别名
  3. 第三顺位执行Bash的内部命令
  4. 第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令

> 快捷键

| 快捷键 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| CTRL+A | 把光标移动到命令行开头。如果我们输入的命令过长，想要把光标移动到命令行开头时使用 |
| CTRL+E | 把光标移动到命令行结尾                                       |
| CTRL+C | 强制终止当前的命令                                           |
| CTRL+L | 清屏，相当于clear命令                                        |
| CTRL+U | 删除或剪切光标之前的命令                                     |
| CTRL+K | 删除或剪切光标之后的内容                                     |
| CTRL+Y | 粘贴ctrl+U或ctr\|+K剪切的内容                                |
| CTRL+R | 在历史命令中搜索，按下ctrl+R之后，就会出现搜索界面，只要输入  搜索内容，就会从历史命令中搜索 |
| CTRL+D | 退出当前终端                                                 |
| CTRL+Z | 暂停，并放入后台。这个快捷键牵扯工作管理的内容               |
| CTRL+S | 暂停屏幕输出                                                 |
| CTRL+Q | 恢复屏幕输出                                                 |



> 多命令执行

| 多命令执行符 | 格式             | 作用                                                         |
| ------------ | ---------------- | ------------------------------------------------------------ |
| ；           | 命令1 ； 命令2   | 多个命令顺序执行，命令之间没有任何逻辑联系                   |
| &&           | 命令1 && 命令2   | 逻辑与  当命令1正确执行，则命令2才会执行  当命令1执行错误，则命令2不会执行 |
| \|\|         | 命令1 \|\| 命令2 | 逻辑或  当命令1执行不正确，则命令2才会执行  当命令1正确执行，则命令2不会执行 |



> 通配符和其他符号

| 通配符 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| ？     | 匹配一个任意字符                                             |
| *      | 匹配0个或任意多个字符                                        |
| []     | 匹配中括号中任意一个字符。例：`[abc]`代表一定匹配一个字符，或者a，或者b，或者c |
| [-]    | 匹配中括号中任意一个字符，-代表一个范围。例：`[a-z]`代表匹配一个小小字母 |
| [^]    | 逻辑非，表示匹配不是中括号内的一个字符。例：`[^0-9]`代表匹配不是一个数字的字符 |

| 符号 | 作用                                                         |
| ---- | ------------------------------------------------------------ |
| ''   | 单引号。在单引号中所有的特殊符号，如 & 和 `都没有特殊含义    |
| ""   | 双引号。在双引号中特殊符号都没有特殊含义，但是 “&” 、“`”和“ \”是例外，拥有“调用变量的值”、“引用命令”、“转义符”的特殊含义。 |
| ``   | 反引号。反引号括起来的内容是系统命令，在Bash中会先执行它。和&( )作用一样。 |
| &()  | 和反引号相同。                                               |
| #    | 在shell脚本中，#开头的行代表注释。                           |
| $    | 用于调用变量的值，如需要调用变量name的值时，需要用$name的方式得到变量的值。 |
| \    | 转义符，跟在\之后的特殊符号将失去特殊含义，变为普通字符。    |



> 减号 - 的用途

管线命令在bash 的连续的处理程序中是相当重要的!另外，在log file的分析当中也是相当重要的一环，所以请特别留意! 另外，在管线命令当中，常常会使用到前一个指令的stdout 作为这次的stdin，某些指令 需要用到文件名(例如tar) 来进行处理时，该stdin 与stdout 可以利用减号"-"来替代

````shell
tar -cvf - /xuexi/text | tar -xvf -
# 上面这个例子是说: 「我将/xuexi/test里面的文件给他打包，但打包的数据不是纪录到文件，而是传送到stdout; 经过管线后， 将tar -cvf - /xuexi/test 传送给后面的tar -xvf - 。后面的这个-则是取用前一个指令的stdout,
````











## 帮助               

<font color=#0000FF>**获得帮助信息：**</font>`man `          manual

语法：`man 命令或配置文件`

````shell
man ls     # 查看ls 的命令帮助信息
````

 

<font color=#0000FF>**获得内置命令帮助信息：**</font>`help`

语法：`help 命令`

​    

# VIM

> 移动命令

| 移动命令 | 描述         |
| -------- | ------------ |
| h 或 ←   | 光标向左移动 |
| j 或↓    | 光标向下移动 |
| k 或↑    | 光标向上移动 |
| l 或→    | 光标向右移动 |



> 插入命令

| 插入命令 | 描述                 |
| -------- | -------------------- |
| a        | 在光标所在字符后插入 |
| A        | 在光标所在行尾插入   |
| i        | 在光标所在字符前插入 |
| I        | 在光标所在行行首插入 |
| o        | 在光标下插入新行     |
| O        | 在光标上插入新行     |



> 定位命令

| 定位命令  | 描述                    |
| --------- | ----------------------- |
| :set nu   | 设置行号                |
| :set nonu | 取消行号                |
| gg        | 到第一行                |
| G         | 到最后一行              |
| nG        | 到第n行        例：52G  |
| :n        | 到第n行        例：：52 |
| $         | 移至行尾                |
| 0         | 移至行首                |



> 删除命令

| 删除命令 | 描述                           |
| -------- | ------------------------------ |
| x        | 删除光标所在字符               |
| nx       | 删除光标所在处后n字符          |
| dd       | 删除光标所在行                 |
| ndd      | 删除n行                        |
| dG       | 删除光标所在行到文件末尾的内容 |
| D        | 删除光标所在处到行尾的内容     |
| :n1，n2d | 删除n1行到n2行的内容           |



> 复制粘贴

| 复制粘贴 | 描述                         |
| -------- | ---------------------------- |
| yy       | 复制当前行                   |
| nyy      | 复制当前行一下n行            |
| dd       | 剪切当前行                   |
| ndd      | 剪切当前行一下n行            |
| p、P     | 粘贴在当前光标所在行下或行上 |



> 替换和取消

| 替换和取消 | 描述                                |
| ---------- | ----------------------------------- |
| r          | 取代光标所在处字符                  |
| R          | 从光标所在处开始替换字符，按Esc结束 |
| u          | 取消上一步操作                      |



>搜索和搜索替换

| 搜索和搜索替换                       | 描述               |
| ------------------------------------ | ------------------ |
| /指定字符串                          | 搜索指定字符串     |
| :%s/被替换的字符串/新的字符串/g      | 全文替换指定字符串 |
| :n1，n2s/被替换的字符串/新的字符串/g | 指定范围替换字符串 |

* 忽略大小写：`set ic`

* 区分大小写：`set noic`

* n键   查看搜索的字符串的下一个



> 保存和退出

| 保存和退出  | 描述                                     |
| ----------- | ---------------------------------------- |
| :w          | 保存修改                                 |
| :w [文件名] | 另存为指定文件                           |
| :wq         | 保存修改并退出                           |
| ZZ          | 保存修改并退出                           |
| :q！        | 不保存修改退出                           |
| :wq！       | 保存修改并退出（文件所有者及root可使用） |
| :r[文件名]  | 读入另一个文件                           |
| :!命令      | 暂时离开vim 执行命令                     |



> 重复与复原

| 重复与复原 | 描述               |
| ---------- | ------------------ |
| u          | 复原前一个动作     |
| Ctrl + r   | 重复上一个动作     |
| .          | 重复上一个动作     |
| :e！       | 恢复文件的原始状态 |

 

> 区块选择

| 区块选择 | 描述                                 |
| -------- | ------------------------------------ |
| v        | 字符选择，将光标经过的地方反白选择   |
| V        | 列选择，会将光标经过的列反白选择     |
| Ctrl + v | 区块选择，可以用长方形的方式选择资料 |
| y        | 将反白的地方复制                     |
| d        | 将反白的地方删除                     |
| p        | 将刚刚复制的区块，在游标所在处贴上   |



> 多文件编辑

`vim [文件] [文件] [文件]……`

* :n 编辑下一个文件
* :N 编辑上一个文件
* :files 列出目前这个vim开启的所有文件



> 多窗口

* `：sp [文件]` 开启一个新窗口，如果后面添加文件，表示在新窗口开启一个新文件，否则表示两个窗口为同一个文件

* Ctrl+w +j 或 ↓ 光标移到到下方窗口 (按下ctrl+w后松开 再按下j)

* Ctrl+w +k 或 ↑ 光标移到到上方窗口 (按下ctrl+w后松开 再按下k)



> 补全

* Ctrl + x -> ctrl + n 透过目前正在编辑的这个文件的内容进行补全

* Ctrl + x -> Ctrl + f 以当前目录内的文件名进行补全

* Ctrl + x -> Ctrl + o 以扩展名作为语法补充



> 导入：r

导入命令执行结果`:r` 

导入文件 `:r /文件名`

导入执行结果`:r !命令`

````
:r !date       直接导入date命令的结果到光标所在处
:r /tmp/ceshi  导入ceshi文件到光标所在处
````



> 技巧

**快捷键 ：**map （Ctrl + V）快捷键 触发命令

例：：map ^H o 320951152@qq.com<ESC>  

​     定义快捷键Ctrl + H 在光标处添加行并输入邮箱后退出（<ESC>是退出）

 

**连续行注释**（利用搜索替换）：

例：：n1，n2s/^/#/g        在n1行到n2行的开头替换为#   （^是开头的意思）

：n1，n2s/^#//g        把n1行到n2行开头的#替换为空

：n1，n2s/^/\/\//g       在n1行到n2行的开头替换为//   (\为转义符)



替换：ab 

例： ：ab mymail 320951152@qq.com

​    意义： 以后在vim编辑时输入mymail 会变成320951152@qq.com

配置文件在家目录的.vimrc中





# 权限管理



## ACL权限

**作用：**解决所有者、所属组、和其他人三个身份不足的情况



查看分区ACL权限是否开启

* `dumpe2fs -h /dev/sda3`  dumpe2fs 命令是查询指定分区详细文件系统信息的命令
  * `-h` 仅显示超级块中信息，而不是显示磁盘块组的详细信息



**开启分区ACL权限**

* 临时开始分区ACL权限
  * `mount -o remount，acl /`  重新挂载根分区，并挂载加入acl权限

* 永久开启分区ACL权限
  * `vi /etc/fstab`
  * `UUID=c2ca6f57-b15c-43ea-bea0-f239083d8bd2 / ext4  defaults,acl   1 1` 加入acl
  * `mount -o remount /` 重新挂载文件系统或重启动系统，使修改生效



**查看ACL命令：**

* `getfacl 文件名`  查看文件的acl权限



**设定ACL权限：**

* `setfacl [选项] 文件名或目录名`
  * `-m`    设定ACL权限
    * `setfacl -m [用户或组]:[用户名或组名]:[rwx权限] 文件名或目录`
    * 最大有效权限mask:mask是用来指定最大有效权限的。如果我们给用户赋予了ACL权限，是需要和mask的权限“相与”才能得到用户的真正权限 `seftacl -m m:[rwx权限] 文件名` （使用"m:权限"格式）
  * `-x`     删除ACL权限
    * `setfacl -x [用户或组]:[用户或组] 文件名或目录`删除指定用户或组的ACL权限
  * `-b`     删除所有ACL权限
  * `-d`     设定默认ACL权限 (对新建文件)
    * 默认ACL权限：父目录设定了默认ACL权限，父目录中所有新建的子文件都会继承父目录的ACL权限
    * 修改默认ACL权限 `setfacl -m d:[用户或组]:[用户名或组名]:[rwx权限] 目录名`
  * `-k`     删除默认ACL权限
  * `-R`     递归设定ACL权限 (对现有文件)
    * 递归是父目录在设定ACL权限时，所有的子文件或子目录也会拥有相同的ACL权限
    * 递归ACL权限 `setacl -m [用户或组]:[用户名或组名]:[rwx权限] -R 目录名`

````shell
setfacl -m:u:test:rx /ceshi
#给用户 test 添加文件ceshi的读执行权限

setfacl -m g:1ban:rx /ceshi
#给组 1ban 添加ceshi的读执行权限

sefacl -m m:rx 文件名
#设定mask权限为r-x
````

   



## 特殊权限

> **SetUID**

**功能:**

* 只有可以执行的二进制程序和二进制文件才能设定SUID权限
* 命令执行者要对该程序拥有x(执行)权限
* 命令执行者在执行该程序时获得该程序文件属主的身份 (在执行程序的过程中灵魂附体为文件的属主)
* SetUID权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效

````shell
例：passwd命令拥有SetUID权限，所以普通用户可以修改自己的密码
ls -l /usr/bin/passwd

-rwsr-xr-x. 1 root root 25980 7月29 2020 /usr/bin/passwd
#s代表普通用户拥有了passwd的root权限
````



**设定SetUID:**4或S代表SUID

* `chmod 4[rwx权限] 文件名`

* `chmod u+s 文件名`



**取消SetUID:**

* `chmod [rwx权限] 文件名`

* `chmod u-s 文件名`



**危险的SetUID**

* 关键目录应严格控制写权限。比如"/"、"/usr"等

* 对系统中默认应该具有SetUID权限的文件作一列表，定期检查有没有这之外的文件被设置了SetUID权限



> **SetGID**

**对文件的作用**

* 只有可执行的二进制程序才能设置SGID权限

* 命令执行者要对该程序拥有x(执行)权限

* 命令在执行程序的时候，组省份升级为该程序文件的属组

* SetGID权限同样只在该程序执行过程中有效，也就是说组身份改变只在程序执行过程中有效

**对目录的作用**

* 普通用户必须对此目录拥有r和x权限，才能进入此目录

* 普通用户在此目录中的有效组会变成此目录的属组

* 若普通用户在此目录拥有w权限时，新建的文件的默认属组是这个目录的属组



**设置SetGID:**2代表SGID

* `chmod 2[rwx权限] 文件名`

* `chmod g+s 文件名`



**取消SetGID:**

* `chmod [rwx权限] 文件名`

* `chmod g-s 文件名`



> **Sticky BIT**

**作用**

* 粘着位目前只对目录有效
* 普通用户对该目录拥有w和x权限，即普通用户可以在此目录拥有写入权限
* 如果没有粘着位，因为普通用户拥有w权限，所有可以删除此目录下所有文件，包括其它用户建立的文件，一但赋予了粘着位，除了root可以删除所有文件，普通用户就算拥有了w权限也只能删除自己建立的文件，但是不能删除其它用户建立的文件

````shell
# /tmp 拥有SBIT权限，所以普通用户可以读写文件，但不能删除其它用户建立的文件

ll -h /tmp/
drwxrwxrwt. 39 root root 4.0K 7月  29 20:18 /tmp
#t代表拥有SBIT权限
````



**设置粘着位:**1或t代表了SBIT

* `chmod 1[rwx权限] 目录名`

* `chmod o+t 目录名`

**取消粘着位：**

* `chmod [rwx权限] 目录名`

* `chmod o-t 目录名`

 

## chattr权限

**命令格式：**`chattr [+-=] [选项] 文件名或目录名`

* `+` 整加权限

* `-` 删除权限
* `=` 等于权限

* 选项：
  * `i` 如果对文件设置i属性，那么不允许对文件进行删除、改名，也不能添加和修改数据；如果对目录设置i属性，那么只能修改目录下文件的数据，但不允许建立和删除文件
  * `a` 如果对文件设置a属性，那么只能在文件中增加数据，但是不能删除也不能修改数据 (添加数据使用echo来添加);如果对目录设置a属性，那么只允许在目录中建立和修改文件，但是不允许删除文件

````shell
chattr +a /tmp/test 
#对/tmp/test 文件添加a属性
````



**查看文件系统属性**

* `lsattr [选项] 文件名`
  * `-a` 显示所在文件和目录
  * `-d` 若目标是目录，仅列出本目录本身的属性，而不是子文件的属性



## sudo权限

**作用:**

* root把本来只能超级用户执行的命令赋予普通用户执行
* sudo的操作对象是系统命令

**授权:**`visudo`

`[用户名或%组名]  [被管理主机地址]=[(可使用身份)] [授权地址的绝对路径]`

````shell
visudo
#实际修改的是/etc/sudoers 文件

root    ALL=(ALL)                         ALL
#用户名  被管理主机的地址= (可使用的身份)      授权命令(绝对路径)

%whell  ALL=(ALL)                        ALL
#%组名  被管理主机的地址= (可使用的身份)       授权命令(绝对路径)


# 例：授权shanghai用户可以重启服务器
visudo
# 添加
shanghai ALL= /sbin/shutdown -r now
````



**使用：**

* 查看可执行的sudo命令

* * `sudo  -l`

* 执行sudo命令

* * `sudo [命令绝对地址] [选项] ……`

````shell
# 例：普用户执行sudo赋予的命令
sudo -l
#查看可执行的sudo命令

sudo /sbin/shutdown -h now
#普通用户执行sudo赋予的命令
````





# 文件系统

## 分区和文件系统

> **分区**

**分区类型**

* 主分区:总共最多只能分四个

* 扩展分区:只能有一个，也算作主分区的一种，也就是说主分区加扩展分区最多有四个。但是扩展分区不能存储数据和格式化，必须再划分成逻辑分区才能使用。

* 逻辑分区:逻辑分区是在扩展分区中划分的，如果是IDE硬盘，Linux最多 支持59个逻辑分区；如果是SCSI硬盘Linux最多支持11个逻辑分区

**分区表示方法**

![image-20220717113633491](linux.assets/image-20220717113633491.png)



> **文件系统**

* **ext2**:是ext文件系统的升级版本，RedHat Linux7.2版本以前的系统默认都是ex文件系统。1993年发布，最大支持16TB的分区和最大2TB的文件

* **ext3**:ext3文件系统是ext2文件系统的升级版本，最大的区别就是带日志功能，以在系统突然停止时提高文件系统的可靠性,支持最大16TB的分区和最大2TB的文件

* **ext4**:它是ext3文件系统的升级版。ext4在性能、伸缩性和可靠性方面进行了大量改进。EXT4的变化可以说是翻天覆地的，比如向下兼容EXT3、最大1EB文件系统和16TB文件、无限数量子目录、Extents连续数据块概念、多块分配、延迟分配、持久预分配、快速FSCK、日志校验、无日志模式、在线碎片整理、iinode增强、默认启用barrier等。是CentOS 6.3的默认文件系统( 1EB= 1024PB= 1024* 1024TB )



## 文件系统命令

<font color=#0000FF>**查看文件使用情况：**</font>`df`                    disk free

语法：`df [选项] 挂载点`

* `-a` 显示所有的文件系统信息，包括特殊文件系统，如/proc、/svsfs
* `-h` 使用习惯单位显示容量，如KB、MB、GB
* `-T` 显示文件系统类型
* `-m` 以MB为单位
* `-k` 以KB为单位
* `-i` 显示inode 信息而非块使用量



<font color=#0000FF>**统计目录或文件大小：**</font>`du`                 disk usage

语法：`du [选项] 目录或文件名`

* `-a` 显示每个子文件的磁盘占有量。默认只统计子目录的磁盘占用量
* `-h` 使用习惯单位显示磁盘占用量
* `-s` 统计总占用量，而不列出子目录和子文件的占用量

**du命令和df命令的区别**

* `df`命令是从文件系统考虑的，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间(最常见的就是文件已经删除，但是程序并没有释放空间)

* `du`命令是面向文件的，只会计算文件或目录占用的空间



<font color=#0000FF>**文件修复：**</font>`fsck`                      file system check

语法：`fsck [选项] 分区设备文件名`

* `-a` 不显示用户提示，自动修复文件系统
* `-y` 自动修复。和-a作用一致，不够有些文件系统只支持-y



<font color=#0000FF>**格式化命令：**</font>`mkfs`                 make file system

语法：`mkfs [-V] [-t fstype] [fs-options] filesys [blocks]`

* `device` 预备检查的硬盘分区，例如：/dev/sda1
* `-V`    详细显示模式
* `-t`    给定档案系统的型式，Linux 的预设值为 ext2

````shell
mkfs -t ext3 /dev/sda6  
# 将sda6分区格式化为ext3格式
````



<font color=#0000FF>**显示磁盘状态命令：**</font>`dumpe2fs`

* `dumpe2fs 分区设备文件名`（CentOS 使用 `xfs_info`）

* `blkid`命令对查询设备上所采用文件系统类型进行查询

 

<font color=#0000FF>**挂载命令：**</font>

查询:`mount -l `查询系统中已经挂载的设备，-l会显示卷标名称(查询不使用-l命令一样可以查询)

自动挂载:`mount -a` 依据配置文件/etc/fstab的内容，自动挂载(U盘等不可以自动挂载)

语法:`mount [选项] 设备文件名 挂载点`

* `-t` 文件系统  加入文件系统类型来指定挂载类型，可以ext3、ext4、光盘iso9660等文件系统

* `-L` 卷标名    挂载指定卷标的分区，而不是安装设备文件名挂载

* `-o` 特殊选项  可以指定挂载的额外选项

| 参数          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| atime/noatime | 更新访问时间/不更新访问时间。访问分区文件时，是否更新文件的访问时间，默认为更新 |
| async/sync    | 异步/同步，默认为异步                                        |
| auto/noauto   | 自动/手动，mount -a命令执行时，是否会自动安装/etc/fstab文件  |
| defaults      | 定义默认值，相当于rw,suid,dev,exec,auto,nouser,asymc这七个选项 |
| exec/noexec   | 执行/不执行，设定是否允许在文件系统中执行可执行文件，默认是exec允许 |
| remount       | 重新挂载已经挂载的文件系统，一般用于指定修改特殊权限         |
| rw/ro         | 读写/只读，文件系统挂载时，是否具有读写权限，默认是rw        |
| suid/nosuid   | 具有1不具有SUID权限，设定文件系统是否具有SUID和SGID的权限，默认是具有 |
| user/nouser   | 允许/不允许普通用户挂载，设定文件系统是否允许普通用户挂载，默认是不允许，只有root可以挂载分区 |
| usrquota      | 写入代表文件系统支持用户磁盘配额，默认不支持                 |
| grpquota      | 写入代表文件系统支持组磁盘配额，默认不支持                   |



**挂载光盘与U盘**

挂载光盘

````shell
mkdir /mnt/cdrom
#建立挂载点
mount -t iso9660 /dev/cdrom /mnt/cdrom
#挂载光盘
或者（mount /dev/sr0 /mnt/cdrom #因为/dev/cdrom是/sr0 的软链接)
````

挂载U盘

````shell
fdisk -l
#查看U盘设备文件名
mount -t vaft /dev/sdb1 /mnt/usb/
````

卸载命令

````shell
umount 设备文件名或挂载点
````



## fdisk分区

**fdisk 命令分区过程**

````shell
[root@localhost ~]# fdisk -l                                     #获取设备文件名
[root@localhost ~]# fdisk /dev/sdb                               #准备分区

命令(输入 m 获取帮助)：n
Partition type:
   p   primary (1 primary, 0 extended, 3 free)                   #(主分区)
   e   extended                                                  #(扩展分区)

Select (default p): p                                            #添加主分区

……

命令(输入 m 获取帮助)：n
Select (default p): e                                             #添加扩展分区

……
命令(输入 m 获取帮助)：n                                            #新建分区

Partition type:
   p   primary (1 primary, 1 extended, 2 free)
   l   logical (numbered from 5)                                 #(逻辑分区)

Select (default p): l                                            #建立逻辑分区
……

命令(输入 m 获取帮助)：w                                            #保存退出

[root@localhost ~]# fdisk -l                                     #获取分区信息
…
/dev/sdb1            2048     4196351     2097152   83  Linux                    
/dev/sdb2         4196352    20971519     8387584    5  Extended #扩展分区不需要挂载
/dev/sdb5         4198400    20971519     8386560   83  Linux
……

[root@localhost ~]# mkfs.xfs /dev/sdb1                          #格式化
……
[root@localhost ~]# mkfs.xfs /dev/sdb5                          #格式化
……
[root@localhost ~]# mkdir /disk1                                #建立挂载点
[root@localhost ~]# mkdir /disk5                                #建立挂载点
[root@localhost ~]# mount /dev/sdb1 /disk1/
[root@localhost ~]# mount /dev/sdb5 /disk5/                     #挂载
````

**菜单操作说明**

| 命令 | 说明                                                      |
| ------ | ----------------------------------------------------------- |
| n    | 新建分区                                                |
| m    | 显示帮助菜单                                              |
| w    | 保存退出                                                  |
| q    | 不保存退出                                              |
| a    | 设置可引导标记                                           |
| b    | 编辑bsd磁盘标签                                           |
| c                                   |设置DOS操作系统兼容标记|
| d                                             |删除一个分区|
| l    | 显示己知的文件系统类型。82为Linux swap分区，83为Linux分区 |
| o    | 建立空白DOS分区表                                        |
| p    | 显示分区列表                                              |
| s    | 新建空白SUN磁盘标签                                       |
| t    | 改变一个分区的系统ID                                      |
| u    | 改变显示记录单位                                         |
| v    | 验证分区表                                                |
| x    | 附加功能(仅专家)                                       |



## 日志

在CentOS 6.x中日志服务已经由rsyslogd取代了原先的syslogd服务。rsyslogd日志服务更加先进，功能更多。但是不论该服务的使用，还是日志文件的格式其实都是和syslogd服务相兼容的，所以学习起来基本和syslogd服务一 致。

| 日志文件          | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| /var/log/cron     | 记录系统定时任务相关日志                                     |
| /var/log/cups/    | 记录打印信息的日志                                           |
| /var/log/dmesg    | 记录了系统开机时内核自检的信息。也可以使用dmesg命令直接查看  |
| /var/log/btmp     | 记录错误登录的日志，使用lastb命令查看                        |
| /var/log/lasstlog | 记录系统中所有用户最后一次的登录时间日志，使用lastlog命令查看 |
| /var/log/mailog   | 记录邮件信息                                                 |
| /var/log/message  | 记录系统重要信息的日志                                       |
| /var/log/secure   | 记录验证和授权方面的信息                                     |
| /var/log/wtmp     | 永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件，使用last查看 |
| /var/run/utmp     | 记录当前已经登录的用户信息，使用w、who、users查看            |



> **rsyslogd服务**

**格式:**

* 事件产生的事件
* 发生事件的服务器主机名
* 产生事件的服务名或程序名
* 事件的具体信息



**/etc/rsyslog.conf配置文件**

服务名称

| 服务名称      | 说明                                                        |
| ------------- | ----------------------------------------------------------- |
| auth          | 安全和认证相关信息                                          |
| authpriv      | 安全和认证相关信息(私有)                                    |
| cron          | 系统定时任务cront和at产生的日志                             |
| daemon        | 和各个守护进程相关的日志                                    |
| ftp           | ftp守护进程产生的日志                                       |
| kern          | 内核产生的日志                                              |
| local0-local7 | 为本地使用预留的服务                                        |
| lpr           | 打印产生的日志                                              |
| mail          | 邮件收发信息                                                |
| news          | 与新闻服务器相关的日志                                      |
| syslog        | 由syslogd服务产生的日志信息                                 |
| user          | 用户等级类别的日志信息                                      |
| uucp          | uucp子系统的日志信息，uucp是早期linux系统进行数据传递的协议 |

日志等级

| 等级名称 | 说明                                                |
| -------- | --------------------------------------------------- |
| debug    | 一般的调试信息说明                                  |
| info     | 基本的通知信息                                      |
| notice   | 普通信息，但是有一定的重要性                        |
| warning  | 警告信息，不会影响服务或系统的运行                  |
| err      | 错误信息，一般达到err等级的信息影响服务或系统的运行 |
| crit     | 临界状况信息，比err等级严重                         |
| alert    | 警告状态信息，比crit严重                            |
| emerg    | 疼痛等级信息，系统无法使用                          |

连接符号可以识别为:

* `*`代表所有日志等级，比如: `authpriv.*`代表authpriv认证信息服务产生的日志，所有的日志等级都记录
* `.`代表只要比后面的等级高的(包含该等级)日志都记录下来。比如:`cron.info`代表cron服务产生的日志，只要日志等级大于等于info级别，就记录
* `.=`代表只记录所需等级的日志，其他等级的都不记录。比如:`*.=emerg` 代表人和日志服务产生的日志，只要等级是emerg等级就记录。这种用法及少见，了解就好
* `.!`代表不等于，也就是除了该等级的日志外，其他等级的日志都记录

````shell
authpriv.*   /var/log/secure
#认证相关服务.所有日志等级  记录在/var/log/secure文件
````



 

# 系统管理

## 进程管理

进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。



<font color=#0000FF>**查看系统健康状况：**</font>`TOP`

作用：top命令可以实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统性能和运行信息的实用工具，TOP命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，有点像window系统的任务管理器

语法：`top [选项]`

* `-d 秒数`  指定top命令每隔几秒更新。默认3秒

在top命令的交互模式当中可以执行的命令(Shift + 选项)：

* ？        或h 显示交互模式的帮助
* P        以CPU使用率排序，默认就是此项
* M        以内存使用率排序
* N        以PID排序
* q        退出top



````txt
top - 22:04:21 up  2:50,  2 users,  load average: 0.05, 0.04, 0.05
Tasks: 230 total,   1 running, 229 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.0 us,  3.3 sy,  0.0 ni, 96.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  1863040 total,    67664 free,   832892 used,   962484 buff/cache
KiB Swap:  2097148 total,  2096628 free,      520 used.   838120 avail Mem 
````

第一行为任务队列信息

| 内容                           | 说明                            |
| ------------------------------ | ------------------------------- |
| 22:04:21                       | 系统当前时间                    |
| up 2:50                        | 系统的运行总时长                |
| 2 users                        | 当前登录几个用户                |
| load average: 0.05, 0.04, 0.05 | 系统在之前1、5/15分钟的平均负载 |

第二行为进程信息

````txt
Tasks: 230 total,  1 running, 229 sleeping,  0 stopped,  0 zombie
````

| 内容             | 说明             |
| ---------------- | ---------------- |
| Tasks: 230 total | 系统中的进程总数 |
| 1 running        | 正在运行的进程数 |
| 229 sleeping     | 睡眠的进程数     |
| 0 stopped        | 正在停止的进程   |
| 0 zombie         | 僵尸进程         |

第三行为CPU信息

````txt
%Cpu(s): 0.0 us, 3.3 sy, 0.0 ni, 96.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st
````

| 内容            | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| %Cpu(s): 0.0 us | 用户模式占用的CPU百分比                                      |
| 3.3 sy          | 系统模式占用的CPU百分比                                      |
| 0.0 ni          | 改变过优先级的用户进程占用的CPU百分比                        |
| 96.7 id         | 空闲CPU的百分比                                              |
| 0.0 wa          | 等待输入/输出的进程的占用CPU百分比                           |
| 0.0 hi          | 硬中断请求服务器占用的CPU百分比                              |
| 0.0 si          | 软中断请求服务器占用的CPU百分比                              |
| 0.0 st          | 虚拟时间百分比。就是当有虚拟机时，虚拟CPU等待实际CPU的时间百分比 |

第四行为物理内存信息

````txt
KiB Mem : 1863040 total,  67664 free,  832892 used,  962484 buff/cache
````

| 内容              | 说明                   |
| ----------------- | ---------------------- |
| Mem:1863040 total | 物理内存的总量，单位kb |
| 67664 free        | 空闲的物理内存数量     |
| 832892 used       | 已经使用的物理内存数量 |
| 962484 buff/cache | 作为缓冲的内存数量     |

第五行为交换分区(swap)信息

`````txt
KiB Swap: 2097148 total, 2096628 free,   520 used.  838120 avail Mem 
`````

| 内容               | 说明                     |
| ------------------ | ------------------------ |
| Swap:2097148 total | 交换分区的大小           |
| 2096628 free       | 空闲交换分区的大小       |
| 520 used           | 已经使用的交换分区的大小 |
| 838120 avail Mem   | 作为缓存的交换分区大小   |

 

<font color=#0000FF>**查看进程统计信息：**</font>`ps`                       process status

语法：`ps 选项`

* `a`： 显示当前终端下的所有进程信息，包括其他用户的进程。
* `u`： 使用以用户为主的格式输出进程信息。
* `x`： 显示当前用户在所有终端下的进程。
* `-e`：显示系统内的所有进程信息。
* `-l`：使用长（long）格式显示进程信息。
* `-f`：使用完整的（full）格式显示进程信息。
* `-T`：查看进程下面的子线程

常用：

* `ps aux`  查看系统中所有进程，使用BSD操作系统格式

* `ps -le`  查看系统中所有进程，使用linux标准命令格式

| 内容    | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| USER    | 该进程是由哪个用户产生的                                     |
| PID     | 进程的ID号                                                   |
| %CPU    | 该进程占用CPU资源的百分比                                    |
| %MEM    | 该进程占用物理内存的百分比                                   |
| VSZ     | 该进程占用虚拟内存的大小，单位kb                             |
| RSS     | 该进程占用实际物理内存                                       |
| TTY     | 该进程是在哪个终端中运行                                     |
| STAT    | 进程状态，R：运行、S：睡眠、T：停止状态、s：包含子进程、+：位于后台 |
| START   | 该进程的启动时间                                             |
| TIME    | 该进程占用CPU的运算时间                                      |
| COMMAND | 产生此进程的命令名                                           |

<font color=#0000FF>**查找指定进程：**</font>`ps -ef | grep 进程关键字`

````shell
ps -le | grep tomcat
````



<font color=#0000FF>**查看进程树：**</font>`pstree`

语法：`pstree [选项]`

* `-p：`   显示进程的PID

* `-u：`   显示进程的所属用户



<font color=#0000FF>**终止进程：**</font>`kill`

语法：`kill [信号/选项] 进程ID`

* 选项
  * `-l`           查看可用的进程号

* 信号
  * `-1`           重启进程
  * `-9`           强制杀死进程
  * `-15`          正常停止进程

````shell
kill 12345         # 杀死进程号为12345的进程
kill -1 12345      # 重启进程号为12345的进程
kill -9 12345      # 强制杀死进程号为12345的进程
````



<font color=#0000FF>**按照进程名终止进程：**</font>`pkill`

语法：`pkill [选项] [信号] 进程名`

* `-t 终端号` 按照终端号踢出用户

````sehll
[root@localhost ~]# w
#使用w命令查询本机已经登录的用户
[root@localhost ~]# pkill -t -9 pts/1
#强制杀死从pts/I虚拟终端登录的进程
````





## 工作管理

<font color=#0000FF>**放入后台：**</font>

* 进程 + `&` (放入后台运行) 
* 进程运行时按 Ctrl + z (放入后台暂停)

````shell
tar -zcf etc.tar.gz /etc & 


top
#在top命令执行时，按Ctrl + z
````



<font color=#0000FF>**查看后台：**</font>`jobs`

语法：`jobs [选项]`

* `-l`    显示工作的PID

显示结果：

* `+` 代表最近一个放入后台的工作，工作恢复时，默认恢复的工作

* `-` 代表倒数第二个放入后台的工作



<font color=#0000FF>**将后台暂停的工作恢复到前台执行：**</font>`fg `               Foreground

语法：`fg %工作号`

* `%工作号`： %号可省略，注意工作号(jobs 查看)和PID的区别

<font color=#0000FF>**把后暂停的工作恢复到后台执行：**</font>`bg`                Background

语法：`bg %工作号` 

注意：后台恢复执行命令，是不能和前台有交互的，否则不能恢复到后台执行



## 查看系统资源

<font color=#0000FF>**进程打开或使用的文件信息：**</font>`lsof`

语法：`lsof [选项]`

* `-c字符串`           只列出以字符串开头的进程打开的文件

* `-u用户名`           只列出某个用户的进程打开的文件

* `-p pid`            列出某个PID进程打开的文件
* `-i:端口`            查看端口的占用情况



<font color=#0000FF>**内存状态：**</font>`free`

语法：`free [选项]`

* `-b`              以字节为单位显示

* `-k`              以KB为单位显示，默认就是以KB为单位显示

* `-m`              以MB为单位显示

* `-g`              以GB为单位显示
* `-t` 　           显示内存总和列

缓存和缓冲的区别：简单来说缓存( cache)是用来加速数据从硬盘中“读取”的，而缓冲(buffer)是用来加速数据“写入”硬盘的



<font color=#0000FF>**监控系统资源：**</font>`vmstat`

语法：`vmstat [刷新延迟 刷新次数]`

<font color=#0000FF>**开机时内核检测信息：**</font>`dmesg`

<font color=#0000FF>**显示系统的启动时间和平均负载：**</font>`uptime`

显示系统的启动时间和平均负载，也就是top命令的第一行。w命令也可以看到这个数据

<font color=#0000FF>**系统与内核信息：**</font>`uname` 

语法：`uname [选项]`

* `-a`               查看系统所有相关信息
* `-r`               查看内核版本



**查看CPU信息:**`[root@localhost ~]# cat /proc/cpuinfo`

**判断当前系统的位数**:`[root@localhost ~ ]# file /bin/ls`





# Shell

**建立第一个脚本**

打开文本编辑器(可以使用vi/vim 命令来创建文件)，新建一个扩展名为sh的文件(扩展名并不影响脚本执行)

````shell
[root@localhost xuexi]#vim hello.sh                           #sh 一般需要添加代表脚本

#！bin/bash                                                   #此行并不是注释，每个脚本必须添加
echo -e "hello world"                                         #脚本
````

**`#！bin/bash` 中的`#！`是一个约定的标记**，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell

**脚本执行**

1、作为可执行程序

````shell
chmod +x hello.sh  #使脚本具有执行权限
.hello.sh          #执行脚本
````

2、作为解释器参数:这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名

````shell
/bin/sh hello.sh
bin/bash hello.sh

# 这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。
````



## 变量

> 本地变量

定义变量：`变量名=变量值`  (变量名和等号之间不能有空格)

调用变量：`$变量名` 或 `${变量名}`

查看变量：`set`

删除变量：`unset 变量名`



> 环境变量

用户自定义变量只在当前的Shell中生效,而环境变量会在当前Shell和这个Shell的所有子Shell当中生效。如果把环境变量写入相应的配置文件，那么这个环境变量就会在所有的Shell中生效

定义变量：`export变量名=变量值`
查询变量：`env`
删除变量：`unset 变量名`



**只读变量：**`readonly 变量名`

**键盘输入**

* `read [选项] [变量名]`
  * `-p`  提示信息   在等待read输入时，输出提示信息
  * `-t`  秒数      read命令会一直等待用户输入，使用此选项可以指定等待时间(时间超过自动跳过)
  * `-n`  字符数     read命令只接受指定的字符数
  * `-s`            隐藏输入的数据

````shell
[root@localhost shanghai]# vi test.sh 
#!/bin/bash
read -t 30 -p "请输入你的名字: " name                    
read -t 30 -s -p "请输入你的年龄: " sex                       
echo -e "\n"
read -t 30 -n 1 -p "请输入年的性别[M\F]:" x
echo -e "\n"
echo "姓名：$name 年龄: $sex 性别: $x"
````



**声明变量类型**

* `declare [+/-] [选项] 变量名`
  * `-`  给变量设定类型属性
  * `+ `  取消变量的类型属性
  * `-a` 将变量声明为数组类型
  * `-i ` 将变量声明为整数类型
  * `-x` 将变量声明为环境变量
  * `-p` 显示指定变量的被声明的类型



**数组变量**

语法：`数组名=(值1 值2 ... 值n)`

````shell
array_name=(value0 value1 value2 value3)

# 或者单独定义数组的各个分量
array_name[0]=value0
array_name[1]=value1
array_name[n]=valuen
````

读取数组：`${数组名[下标]}`

````shell
valuen=${array_name[n]}

echo ${array_name[@]}         # 使用 @ 符号可以获取数组中的所有元素

# 取得数组元素的个数,三中方法
length=${#array_name[@]}
length=${#array_name[*]}
lengthn=${#array_name[n]}
````



**数值运算**

1. `declare -i sum=$a+$b`
2. `sum=$(expr $a + $b)`             注意：“+”号左右两侧必须有空格
3. `sum=$(( $a+$b ))` 或 `sum=$[ $a+$b ]`

````shell
[root@localhost shanghai]# cat hello.sh 
#!/bin/bash
a=22
b=33
echo $a + $b                   #22 + 33
declare -i cc=$a+$b
echo $cc                       #55
dd=$(expr $a + $b)
echo $dd
echo $(( $a+$b ))              #55
````



## 传递参数

**位置参数变量**

| 位置参数变量 | 作用                                                         |
| ------------ | ------------------------------------------------------------ |
| $n           | n为数字，$0代表命令本身，$1-$9代表第一到第九个参数，十以上的参数需要用大括号包含，如${10} |
| $*           | 这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体   |
| $@           | 这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待   |
| $#           | 这个变量代表命令行中所有参数的个数                           |

**预定义变量**

| 预定义变量 | 作用                                                         |
| ---------- | ------------------------------------------------------------ |
| $?         | 最后一次执行的命令的返回状态。上次命令正确执行，返回0；错误执行返回非0值； |
| $$         | 当前进程的进程号(PID)                                        |
| $！        | 后台进程的最后一个进程的进程号(PID)                          |

````shell
#!/bin/bash

echo "第一个参数为：$1";

echo "参数个数为：$#";
echo "传递的参数作为一个字符串显示：$*";
````

````txt
# 执行
$ chmod +x test.sh 
$ ./test.sh 1 2 3
第一个参数为：1
参数个数为：3
传递的参数作为一个字符串显示：1 2 3
````



## 条件判断

**判断格式**

* `test [选项] 文件`
* `[ 选项 文件 ]` 注意两侧空格

````shell
test -e /root/install.log
[ -e /root/install.log ] 
````

**按照文件类型进行判断**

| 测试选项 | 作用                                       |
| -------- | ------------------------------------------ |
| -b 文件  | 判断该文件是否存在，并且是否为块设备       |
| -c 文件  | 判断该文件是否存在，并且是否为字符设备文件 |
| -d 文件  | 判断该文件是否存在，并且是否为为目录文件   |
| -e 文件  | 判断该文件是否存在                         |
| -f 文件  | 判断该文件是否存在，并且是否为普通文件     |
| -L 文件  | 判断该文件是否存在，并且是否为符号链接文件 |
| -p 文件  | 判断该文件是否存在，并且是否为管道文件     |
| -s 文件  | 判断该文件是否存在，并且是否为非空         |
| -S 文件  | 判断该文件是否存在，并且是否为套接字文件   |

**按照文件权限进行判断**

| 测试选项 | 作用                                           |
| -------- | ---------------------------------------------- |
| -r文件   | 判断该文件是否存在，并且是否该文件拥有读权限   |
| -w文件   | 判断该文件是否存在，并且是否该文件拥有写权限   |
| -x 文件  | 判断该文件是否存在，并且是否该文件拥有执行权限 |
| -u文件   | 判断该文件是否存在，并且是否该文件拥有SUID权限 |
| -g文件   | 判断该文件是否存在，并且是否该文件拥有SGID权限 |
| -k文件   | 判断该文件是否存在，并且是否该文件拥有SBit权限 |

**两个文件之间进行比较**

| 测试选项        | 作用                                              |
| --------------- | ------------------------------------------------- |
| 文件1 -nt 文件2 | 判断文件1的修改时间是否比文件2的新                |
| 文件1 -ot 文件2 | 判断文件1的修改时间是否比文件2的旧                |
| 文件1 -ef 文件2 | 判断文件1是否和文件2的ionde一致。判断是否为硬链接 |

**两整数之间的比较**

| 测试选项        | 作用                                                  |
| --------------- | ----------------------------------------------------- |
| 整数1 -eq 整数2 | 判断整数1是否和整数2相当      （Equal 相等）          |
| 整数1 -ne 整数2 | 判断整数1是否和整数2不相当      （Not equal 不相等 ） |
| 整数1 -gt 整数2 | 判断整数1是否大于整数2        （Greater than 大于）   |
| 整数1 -lt 整数2 | 判断整数1是否小于整数2        （Less than 小于）      |
| 整数1 -ge 整数2 | 判断整数1是否大于等于整数2                            |
| 整数1 -le 整数2 | 判断整数1是否小于等于整数2                            |

**字符串的判断**

| 测试选项           | 作用                           |
| ------------------ | ------------------------------ |
| -z 字符串          | 判断字符串是否为空             |
| -n 字符串          | 判断字符串是否为非空           |
| 字符串1 == 字符串2 | 判断字符串1是否和字符串2相当   |
| 字符串1 != 字符串2 | 判断字符串1是否和字符串2不相当 |

**多重条件判断**

| 测试选项       | 作用                                                     |
| -------------- | -------------------------------------------------------- |
| 判断1 -a 判断2 | 逻辑与，判断1和判断2都成立，最终的结果才为真  （And 与） |
| 判断1 -o 判断2 | 逻辑或，判断1和判断2有一个成立，最终的结果为真 （Or 或） |
| ！判断         | 逻辑非，使原始的判断式取反                               |





## 流程控制

> **if 语句**

**单分支if条件语句**

````shell
if [ 条件判断式 ] ; then
	程序
fi

# 或者
if [ 条件判断式 ] 
then
	程序
fi
````



**双分支if条件语句**

````shell
if [ 条件判断式 ]
then
	条件成立时，执行程序
else
	条件不成立时，执行程序
fi
````



**多分支if条件语句**

````shell
if [ 条件判断式1 ]
then
	当条件判断式1成立时，执行程序
elif [ 条件判断式2 ]
then                                #注意每一条elif 都需要添加then
	当条件判断式2成立时，执行程序
else
    当所有条件都不成立时，执行程序
fi
````

`if else`的`[...]`判断语句中大于使用`-gt`，小于使用`-lt`

````shell
if [ "$a" -gt "$b" ]; then
    ...
fi
````

如果使用 `((...))` 作为判断语句，大于和小于可以直接使用 > 和 <

````shell
if (( a > b )); then
    ...
fi
````



**if else与test结合**

````shell
num1=$[2*3]
num2=$[1+5]
if test $[num1] -eq $[num2]
then
    echo '两个数字相等!'
else
    echo '两个数字不相等!'
fi
````



**退出exit**

语法：`exit 数字`

````shell
read -p "请输入一个文件：" fold
if [ -z "$fold" ]                          #判断fold是否为空
        then
        echo "未输入"
        exit 1
elif [ ! -e "$fold" ]                      #判断fold是否是文件
        then
        echo "不是文件"
        exit 2
else                                       #其它文件
        echo "其他文件"
        exit 3
fi
````



> **case 语句（相当于switch）**

````shell
case $变量名 in
    “值1”）                                     # 注意引号
		如果变量的值等于值1，则执行程序
		；；                                    # 相当于break
    “值2”）
		如果变量的值等于值2，则执行程序
		；；
     *）                                        # *没有引号
		如果变量的值不是以上的值，则执行此程序
		；；
esac
````

````shell
#!/bin/bash
read -t 30 -p "请输入一个数字:" i
case $i in
"1")
    echo "输入的是1"
    ;;
"2")
    echo "输入的是2"
    ;;
*)
    echo "其他数字"
    ;;
esac
````



> **for 循环**

**语法一**

````shell
for 变量 in 值1 值2 值3……
do
    程序
done
````

````shell
#查询所有的用户
cd /tmp
cut -d ":" -f 1 /etc/passwd >temps          #cut的输出重定向致文件temps
for i in $(cat temps)
do
    echo $i
done

for loop in 1 2 3 4 5
do
    echo "The value is: $loop"
done
````

**语法二**

````shell
for(( 初始值；循环控制条件；变量变化 ))
do
    程序
done
````

````shell
#从1加到100
s=0
for(( i=1;i<=100;i=i+1 ))
do
    s=$(( $s + $i ))
done
````

````shell
#批量添加用户
#!/bin/bash
read -t 30 -p "请输入用户名：" name
read -t 30 -p "请输入用户个数:" num
read -t 30 -p "请输入用户密码:" pass

if [ ! -z "$name" -a ! -z "$num" -a ! -z "$pass" ]
    then
    y=$(echo $num |sed 's/^[0-9]*$//g')
    if [ -z "$y" ]
        then
        for(( i=1;i<=$num;i=i+1 ))
        do
            useradd $name$i &>/dev/null
            echo $pass | passwd --stdin "$name$i" &>/dev/null
        done
    fi
    echo "完成"
fi
````



> **while循环**

**语法一**

````shell
while [ 条件判断式 ]
do
    程序
done
````

````shell
#1~100的和
#!/bin/bash
i=1
s=0
while [ $i -le 100 ]
do
    s=$(( $s + $i))
    i=$(( $i+1 ))
done
echo "$s"
````

**语法二**

````shell
while （（ 循环控制条件 ））
do
    程序
done
````



> **until循环** （与while相反，条件不成立时循环，成立时结束）

````shell
until [ 条件判断式 ]
    do
        程序
done
````

````shell
#1~100的和
#!/bin/bash

i=1
s=0
until [ $i -gt 100 ]            #i大于100时结束
do
    s=$(( $s + $i))
    i=$(( $i+1 ))
done
echo "$s"
````



**跳出循环：**

* `break`    结束所有循环
* `continue` 跳出本次循环



## 函数

**定义函数**

````shell
function 函数名 （）{
    程序段
    return
}
````

**调用函数**：直接`函数名`



````shell
#!/bin/bash
funWithReturn(){
    echo "这个函数会对输入的两个数字进行相加运算..."
    echo "输入第一个数字: "
    read aNum
    echo "输入第二个数字: "
    read anotherNum
    echo "两个数字分别为 $aNum 和 $anotherNum !"
    return $(($aNum+$anotherNum))
}
funWithReturn
echo "输入的两个数字之和为 $? !"
````

````shell
#!/bin/bash
funWithParam(){
    echo "第一个参数为 $1 !"
    echo "第二个参数为 $2 !"
    echo "第十个参数为 $10 !"
    echo "第十个参数为 ${10} !"
    echo "第十一个参数为 ${11} !"
    echo "参数总数有 $# 个!"
    echo "作为一个字符串输出所有参数 $* !"
}

funWithParam 1 2 3 4 5 6 7 8 9 34 73

# 输出结果：
第一个参数为 1 !
第二个参数为 2 !
第十个参数为 10 !
第十个参数为 34 !
第十一个参数为 73 !
参数总数有 11 个!
作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !
````





